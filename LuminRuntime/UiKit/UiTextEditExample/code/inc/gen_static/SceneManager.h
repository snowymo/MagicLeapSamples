// -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING --
//
// THE CONTENTS OF THIS FILE IS GENERATED BY CODE AND
// ANY MODIFICATIONS WILL BE OVERWRITTEN
//
// -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING --

// %BANNER_BEGIN%
// ---------------------------------------------------------------------
// %COPYRIGHT_BEGIN%
//
// Copyright (c) 2018 Magic Leap, Inc. All Rights Reserved.
// Use of this file is governed by the Creator Agreement, located
// here: https://id.magicleap.com/creator-terms
//
// %COPYRIGHT_END%
// ---------------------------------------------------------------------
// %BANNER_END%

// %SRC_VERSION%: 2

#pragma once

#include <DesignManager.h>
#include <SceneDescriptor.h>
#include <SceneBase.h>
#include <scenes.h>

#include <lumin/Prism.h>
#include <lumin/node/Node.h>
#include <lumin/Consts.h>

class ExtendedPrefabManager;
class SceneManager;

class ExtendedSceneManager {
public:

  typedef scenes::SceneDescriptorMap SceneDescriptorMap;
  static const SceneDescriptorMap& getSceneDescriptorMap();

public:

  ExtendedSceneManager(lumin::Prism* prism, ExtendedPrefabManager* extendedSceneManager);
  ~ExtendedSceneManager();

  // Control the state of the Resource and Object models for the specified scene
  using ModelState = DesignManager::ModelState;
  ModelState getModelState(const SceneDescriptor& sceneDescriptor) const;
  void setModelState(const SceneDescriptor& sceneDescriptor, ModelState newState);

  // Get the Scene object. Will be nullptr if the scene is unloaded.
  SceneBase* getScene(const SceneDescriptor& sceneDescriptor);
  template <typename T> T* getScene();

  // Load the scene (if necessary) and return the Scene object.
  SceneBase* loadScene(const SceneDescriptor& sceneDescriptor);
  template <typename T> T* loadScene();

  // Unload the specified scene
  void unloadScene(const SceneDescriptor& sceneDescriptor, ModelState newState=ModelState::Unloaded);
  void unloadScene(SceneBase* scene, ModelState newState=ModelState::Unloaded);
  template <typename T> void unloadScene(ModelState newState=ModelState::Unloaded);

  void loadInitialScenes();
  void unloadAllScenes();

  ExtendedPrefabManager* getExtendedPrefabManager() const;

private:

  typedef SceneBase* (*CreateScene)(ExtendedSceneManager* esm, lumin::Node* root);
  static const CreateScene createScene[1];

private:

  lumin::Prism* const prism_;
  SceneManager* const sceneManager_;
  ExtendedPrefabManager* const extendedPrefabManager_;
  ModelState modelStates_[1];
  SceneBase* scenes_[1];
  lumin::ResourceIDType sceneIds_[1];
};

template <typename T> T* ExtendedSceneManager::getScene() {
  return static_cast<T*>(getScene(T::getClassSceneDescriptor()));
}

template <typename T> T* ExtendedSceneManager::loadScene() {
  return static_cast<T*>(loadScene(T::getClassSceneDescriptor()));
}

template <typename T> void ExtendedSceneManager::unloadScene(ModelState newState) {
  unloadScene(T::getClassSceneDescriptor(), newState);
}
