// -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING --
//
// THE CONTENTS OF THIS FILE IS GENERATED BY CODE AND
// ANY MODIFICATIONS WILL BE OVERWRITTEN
//
// -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING --

// %BANNER_BEGIN%
// ---------------------------------------------------------------------
// %COPYRIGHT_BEGIN%
//
// Copyright (c) 2018 Magic Leap, Inc. All Rights Reserved.
// Use of this file is governed by the Creator Agreement, located
// here: https://id.magicleap.com/creator-terms
//
// %COPYRIGHT_END%
// ---------------------------------------------------------------------
// %BANNER_END%

// %SRC_VERSION%: 2

#include <PrefabManager.h>

#include <lumin/node/RootNode.h>
#include <ml_logging.h>

class PrefabManager : public DesignManager {
public:

  // Create a PrefabManager for the specified prism
  PrefabManager(lumin::Prism* prism);

  lumin::ResourceIDType createPrefabDefinition(const std::string& name, const std::string& resourceModelPath, const std::string& soundModelPath, const std::string& objectModelPath);
  bool destroyPrefabDefinition(lumin::ResourceIDType prefab);

  // Control the state of the Resource and Object models for the specified prefab
  using ModelState = DesignManager::ModelState;
  ModelState getModelState(lumin::ResourceIDType prefab) const;
  void setModelState(lumin::ResourceIDType prefab, ModelState newState);

  // Spawn an instance of a prefab (if necessary) and return the Prefab object.
  lumin::Node* spawn(lumin::ResourceIDType prefab);

private:

  struct Prefab {
    std::string name;
    std::string resourceModelPath;
    std::string soundModelPath;
    std::string objectModelPath;
    lumin::ResourceIDType resourceId = lumin::INVALID_RESOURCE_ID;
    ModelState modelState = ModelState::Unloaded;
    std::string objectModelName;
  };

  Prefab* findPrefab(lumin::ResourceIDType resourceId);
  const Prefab* findPrefab(lumin::ResourceIDType resourceId) const;

  static lumin::ResourceIDType nextResourceId_;
  std::vector<Prefab> prefabs_;
};

lumin::ResourceIDType PrefabManager::nextResourceId_;

PrefabManager::PrefabManager(lumin::Prism* const prism)
: DesignManager(prism) {
}

lumin::ResourceIDType PrefabManager::createPrefabDefinition(const std::string& name, const std::string& resourceModelPath, const std::string& soundModelPath, const std::string& objectModelPath) {
  prefabs_.resize(prefabs_.size() + 1);
  Prefab& prefab = prefabs_.back();
  prefab.name = name;
  prefab.resourceModelPath = resourceModelPath;
  prefab.soundModelPath = soundModelPath;
  prefab.objectModelPath = objectModelPath;
  const lumin::ResourceIDType resourceId = nextResourceId_++;
  prefab.resourceId = resourceId;
  return resourceId;
}

PrefabManager::Prefab* PrefabManager::findPrefab(lumin::ResourceIDType const resourceId) {
  for (auto& prefab : prefabs_) {
    if (prefab.resourceId == resourceId) {
      return &prefab;
    }
  }
  return nullptr;
}

const PrefabManager::Prefab* PrefabManager::findPrefab(lumin::ResourceIDType const resourceId) const {
  for (auto& prefab : prefabs_) {
    if (prefab.resourceId == resourceId) {
      return &prefab;
    }
  }
  return nullptr;
}

void PrefabManager::setModelState(lumin::ResourceIDType const resourceId, ModelState const newState) {

  // once the prefab is a resource, we can accept that object and not have to do this lookup
  Prefab* prefab = findPrefab(resourceId);
  if (!prefab) {
    return;
  }

  DesignManager::setModelState(prefab->resourceModelPath, prefab->objectModelPath, newState, prefab->modelState, prefab->objectModelName);
}

lumin::Node* PrefabManager::spawn(lumin::ResourceIDType const resourceId) {

  // once the scene is a resource, we can accept that object and not have to do this lookup
  Prefab* scene = findPrefab(resourceId);
  if (!scene) {
    ML_LOG(Error, "PrefabManager::spawn no such prefab resourceId");
    return nullptr;
  }

  // Load the models if not already loaded
  if (scene->modelState != ModelState::ResourceAndObjectModelLoaded) {
    setModelState(resourceId, ModelState::ResourceAndObjectModelLoaded);
  }

  // Create and return the scene tree
  lumin::Node* nodeTree = prism_->createAll(scene->objectModelName);
  if (!nodeTree) {
    ML_LOG(Error, "PrefabManager::spawn failed to create the node tree. Is the scene empty?");
    return nullptr;
  }

  return nodeTree;
}

const prefabs::PrefabDescriptorMap& ExtendedPrefabManager::getPrefabDescriptorMap() {
  return prefabs::prefabDescriptorMap;
}

ExtendedPrefabManager::ExtendedPrefabManager(lumin::Prism* prism)
:
  prism_(prism),
  prefabManager_(new PrefabManager(prism)) {

  if (!prefabManager_) {
    ML_LOG(Error, "ExtendedPrefabManager nullptr prefabManager");
    abort();
  }

  // Create all the prefab definitions
  for (auto prefab : getPrefabDescriptorMap()) {
    const PrefabDescriptor& sd = prefab.second;
    const int i = sd.getIndex();
    modelStates_[i] = ModelState::Unloaded;
    prefabIds_[i] = prefabManager_->createPrefabDefinition(sd.getName(), sd.getResourceModelPath(), "", sd.getObjectModelPath());
  }
}

ExtendedPrefabManager::~ExtendedPrefabManager() {
  delete prefabManager_;
}

ExtendedPrefabManager::ModelState ExtendedPrefabManager::getModelState(const PrefabDescriptor& prefabDescriptor) const {
  const int index = prefabDescriptor.getIndex();
  const ModelState modelState = modelStates_[index];
  return modelState;
}

void ExtendedPrefabManager::setModelState(const PrefabDescriptor& prefabDescriptor, ModelState const newState) {
  const int index = prefabDescriptor.getIndex();
  const int prefabId = prefabIds_[index];
  prefabManager_->setModelState(prefabId, newState);
}

PrefabBase* ExtendedPrefabManager::spawn(const PrefabDescriptor& prefabDescriptor) {

  const int index = prefabDescriptor.getIndex();
  const int prefabId = prefabIds_[index];

  // Make sure the models are loaded
  setModelState(prefabDescriptor, ModelState::ResourceAndObjectModelLoaded);

  // Create the prefab node tree
  lumin::Node* const root = prefabManager_->spawn(prefabId);
  if (!root) {
    ML_LOG(Error, "ExtendedPrefabManager failed to create the prefab. Is the prefab empty?");
    return nullptr;
  }

  // Create our prefab object
  const CreatePrefab cs = createPrefab[index];
  PrefabBase* const prefab = cs(this, root);

  // Return the new prefab
  return prefab;
}

void ExtendedPrefabManager::destroyPrefab(PrefabBase* prefab) {
  if (prefab) {
    prefab->deleteNodeTree();
    // TODO: delete prefab; we need to remove all of the prefab's callback references before deletion
  }
}
