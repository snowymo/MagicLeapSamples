// -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING --
//
// THE CONTENTS OF THIS FILE IS GENERATED BY CODE AND
// ANY MODIFICATIONS WILL BE OVERWRITTEN
//
// -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING --

// %BANNER_BEGIN%
// ---------------------------------------------------------------------
// %COPYRIGHT_BEGIN%
//
// Copyright (c) 2018 Magic Leap, Inc. All Rights Reserved.
// Use of this file is governed by the Creator Agreement, located
// here: https://id.magicleap.com/creator-terms
//
// %COPYRIGHT_END%
// ---------------------------------------------------------------------
// %BANNER_END%

// %SRC_VERSION%: 2

#include <SceneManager.h>

#include <lumin/node/RootNode.h>
#include <ml_logging.h>

class SceneManager : public DesignManager {
public:

  // Create a SceneManager for the specified prism
  SceneManager(lumin::Prism* prism);

  lumin::ResourceIDType createSceneDefinition(const std::string& name, const std::string& resourceModelPath, const std::string& soundModelPath, const std::string& objectModelPath);
  bool destroySceneDefinition(lumin::ResourceIDType scene);

  // Control the state of the Resource and Object models for the specified scene
  using ModelState = DesignManager::ModelState;
  ModelState getModelState(lumin::ResourceIDType scene) const;
  void setModelState(lumin::ResourceIDType scene, ModelState newState);

  // Get the Scene object. Will be nullptr if the scene is unloaded.
  lumin::Node* getScene (lumin::ResourceIDType scene) const;
  bool isSceneLoaded(lumin::ResourceIDType scene) const;

  // Load the scene (if necessary) and return the Scene object.
  lumin::Node* loadScene(lumin::ResourceIDType scene);
  void unloadScene(lumin::ResourceIDType scene);

private:

  struct Scene {
    std::string name;
    std::string resourceModelPath;
    std::string soundModelPath;
    std::string objectModelPath;
    lumin::ResourceIDType resourceId = lumin::INVALID_RESOURCE_ID;
    ModelState modelState = ModelState::Unloaded;
    std::string objectModelName;
    lumin::Node* sceneNode = nullptr;
  };

  Scene* findScene(lumin::ResourceIDType resourceId);
  const Scene* findScene(lumin::ResourceIDType resourceId) const;

  static lumin::ResourceIDType nextResourceId_;
  std::vector<Scene> scenes_;
};

lumin::ResourceIDType SceneManager::nextResourceId_;

SceneManager::SceneManager(lumin::Prism* const prism)
: DesignManager(prism) {
}

lumin::ResourceIDType SceneManager::createSceneDefinition(const std::string& name, const std::string& resourceModelPath, const std::string& soundModelPath, const std::string& objectModelPath) {
  scenes_.resize(scenes_.size() + 1);
  Scene& scene = scenes_.back();
  scene.name = name;
  scene.resourceModelPath = resourceModelPath;
  scene.soundModelPath = soundModelPath;
  scene.objectModelPath = objectModelPath;
  const lumin::ResourceIDType resourceId = nextResourceId_++;
  scene.resourceId = resourceId;
  return resourceId;
}

SceneManager::Scene* SceneManager::findScene(lumin::ResourceIDType const resourceId) {
  for (auto& scene : scenes_) {
    if (scene.resourceId == resourceId) {
      return &scene;
    }
  }
  return nullptr;
}

const SceneManager::Scene* SceneManager::findScene(lumin::ResourceIDType const resourceId) const {
  for (auto& scene : scenes_) {
    if (scene.resourceId == resourceId) {
      return &scene;
    }
  }
  return nullptr;
}

void SceneManager::setModelState(lumin::ResourceIDType const resourceId, ModelState const newState) {

  // once the scene is a resource, we can accept that object and not have to do this lookup
  Scene* scene = findScene(resourceId);
  if (!scene) {
    return;
  }

  DesignManager::setModelState(scene->resourceModelPath, scene->objectModelPath, newState, scene->modelState, scene->objectModelName);
}

SceneManager::ModelState SceneManager::getModelState(lumin::ResourceIDType const resourceId) const {

  // once the scene is a resource, we can accept that object and not have to do this lookup
  const Scene* scene = findScene(resourceId);
  if (!scene) {
    return ModelState::Unloaded;
  }

  return scene->modelState;
}

lumin::Node* SceneManager::loadScene(lumin::ResourceIDType const resourceId) {

  // once the scene is a resource, we can accept that object and not have to do this lookup
  Scene* scene = findScene(resourceId);
  if (!scene) {
    ML_LOG(Error, "SceneManager::loadScene no such scene resourceId");
    return nullptr;
  }

  // Early out with the scene if it is already loaded
  if (scene->sceneNode) {
    return scene->sceneNode;
  }

  // Load the models if not already loaded
  if (scene->modelState != ModelState::ResourceAndObjectModelLoaded) {
    setModelState(resourceId, ModelState::ResourceAndObjectModelLoaded);
  }

  // Create and return the scene tree
  scene->sceneNode = prism_->createAll(scene->objectModelName);
  if (!scene->sceneNode) {
    ML_LOG(Error, "SceneManager::loadScene failed to create the node tree. Is the scene empty?");
    return nullptr;
  }

  // Add the scene to the prism, temporarily as a child of the root node
  prism_->getRootNode()->addChild(scene->sceneNode);

  return scene->sceneNode;
}

void SceneManager::unloadScene(lumin::ResourceIDType sceneId) {

  // Make sure we have a scene to unload
  Scene* scene = findScene(sceneId);
  if (!scene) {
    return;
  }

  // Remove our scene from the prism root. If the prism's root node is gone,
  // the prism is already being cleaned up
  lumin::RootNode* rootNode = prism_->getRootNode();
  if (rootNode) {
    rootNode->removeChild(scene->sceneNode);
    lumin::Node::Delete(scene->sceneNode);
  }
  scene->sceneNode = nullptr;
}

const scenes::SceneDescriptorMap& ExtendedSceneManager::getSceneDescriptorMap() {
  return scenes::sceneDescriptorMap;
}

ExtendedSceneManager::ExtendedSceneManager(lumin::Prism* prism, ExtendedPrefabManager* extendedPrefabManager)
:
  prism_(prism),
  sceneManager_(new SceneManager(prism)),
  extendedPrefabManager_(extendedPrefabManager) {

  if (!sceneManager_) {
    ML_LOG(Error, "ExtendedSceneManager nullptr sceneManager");
    abort();
  }

  // Create all the scene definitions
  for (auto scene : getSceneDescriptorMap()) {
    const SceneDescriptor& sd = scene.second;
    const int i = sd.getIndex();
    scenes_[i] = nullptr;
    sceneIds_[i] = sceneManager_->createSceneDefinition(sd.getName(), sd.getResourceModelPath(), "", sd.getObjectModelPath());
  }
}

ExtendedSceneManager::~ExtendedSceneManager() {
  unloadAllScenes();
  delete sceneManager_;
}

ExtendedSceneManager::ModelState ExtendedSceneManager::getModelState(const SceneDescriptor& sceneDescriptor) const {
  const int index = sceneDescriptor.getIndex();
  const int sceneId = sceneIds_[index];
  return sceneManager_->getModelState(sceneId);
}

void ExtendedSceneManager::setModelState(const SceneDescriptor& sceneDescriptor, ModelState const newState) {
  const int index = sceneDescriptor.getIndex();
  const int sceneId = sceneIds_[index];
  sceneManager_->setModelState(sceneId, newState);
}

void ExtendedSceneManager::loadInitialScenes() {
  // Iterate over all the exported scenes and load any marked as initially loaded
  for (auto& scene: getSceneDescriptorMap()) {
    const SceneDescriptor& sceneDescriptor  = scene.second;
    if (sceneDescriptor.isInitiallyLoaded()) {
      loadScene(sceneDescriptor);
    }
  }
}

void ExtendedSceneManager::unloadAllScenes() {
  // Iterate over all the exported scenes and unload
  for (auto& scene: getSceneDescriptorMap()) {
    const SceneDescriptor& sceneDescriptor  = scene.second;
    unloadScene(sceneDescriptor);
  }
}

SceneBase* ExtendedSceneManager::getScene(const SceneDescriptor& sceneDescriptor) {

  const int index = sceneDescriptor.getIndex();
  SceneBase* scene = scenes_[index];
  return scene;
}

SceneBase* ExtendedSceneManager::loadScene(const SceneDescriptor& sceneDescriptor) {

  // If the scene was already loaded, return that scene
  const int index = sceneDescriptor.getIndex();
  SceneBase* scene = scenes_[index];
  if (scene) {
    return scene;
  }

  const lumin::ResourceIDType sceneId = sceneIds_[index];

  // Make sure the models are loaded
  setModelState(sceneDescriptor, ModelState::ResourceAndObjectModelLoaded);

  // Create the node tree
  lumin::Node* const root = sceneManager_->loadScene(sceneId);
  if (!root) {
    ML_LOG(Error, "ExtendedSceneManager failed to create the scene. Is the scene empty?");
    return nullptr;
  }

  // Create our scene object
  const CreateScene cs = createScene[index];
  scene = cs(this, root);

  // Add our scene to the prism root
  prism_->getRootNode()->addChild(root);

  // Set and return the new scene
  scenes_[index] = scene;
  return scene;
}

void ExtendedSceneManager::unloadScene(SceneBase* const scene, ModelState newModelState) {
  if (!scene) {
    return;
  }
  const SceneDescriptor& sd = scene->getSceneDescriptor();
  unloadScene(sd, newModelState);
}

void ExtendedSceneManager::unloadScene(const SceneDescriptor& sceneDescriptor, ModelState newModelState) {

 // If the scene was already loaded, return that scene
  const int index = sceneDescriptor.getIndex();
  SceneBase* scene = scenes_[index];
  if (!scene) {
    return;
  }

  const lumin::ResourceIDType sceneId = sceneIds_[index];

  sceneManager_->unloadScene(sceneId);
  sceneManager_->setModelState(sceneId, newModelState);
}

ExtendedPrefabManager* ExtendedSceneManager::getExtendedPrefabManager() const {
  return extendedPrefabManager_;
}

